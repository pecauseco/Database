Questions

1. Consider the thread created in start_listener. How many threads with this functionality should be running on the server at any given time?
We only want one thread with this functionality running at any one time because this thread's function is to listen for other threads. To have multiple threads performing this function would cause unnecessary issues that one thread can take care of on its own. Overall, there really is no need to have more listener threads so we should only be having one of these threads to ensure our database is functioning correctly and accepting and not accepting clients at the right time.

2. In the listener function, what do each of the following fields of the sockaddr_in struct represent: sin_family, sin_port, and sin_addr.s_addr?
The sin_family represent the address family being passed into sockaddr_in, which we usually set to AF_INET. Sin_port represents the port number that we are running on and is further address information that will help us recognize our socket and allow us to make connections to it later on. The sin_addr.s_addr represents the IP address and usually we set it to INADDR_ANY which will accept any address.

3. What is the purpose of each of the following function calls in listener: socket, bind, listen, and accept? You should explain what each call does and what the effect would be if it were not called.
What socket does is it create's a socket that other clients can bind to. It returns an int/file descriptor that a coder can perform operations on that will allow you to achieve functionality of your program, in this case a database server that accepts clients. If it were not called, there would be no way of creating the connection between server and clients. What bind does, is that it gives the socket a name based on the address given to it in the sockaddr_in struct which is in this case addr. If it were not called, there would be errors trying to access the socket because it would not have th correct addresses and names specified to it. What listen does is that it ensures that the socket that it is called on is now listening and accepting new connections so that our clients can join. If it were not called, our socket would not be in an accepting state. Finally, accept will accept incoming connections by making a new socket that will not be taking in new connections and not affecting the old one.

4. Which protocol (TCP or UDP) is used for communication? Why is this protocol used? (Hint: see line 37 in comm.c)
In this project we utilizied the TCP protocol for communication. This protocol ensures that when data is transferred, it gets to its location by establishing a connection between the two entities. UDP operates differently in that it does not check to see if something has arrived after it sends out data. This makes it a little bit more unsafe. We used TCP to ensure that what we were editing actually occurred and because we wanted to form real connections between our server and clients unlike what wou;d have happened in UDP. Furthermore, TCP makes sure messages arrive in an order whereas UDP does not perserve order which is important for this project in which different calls are happening at different times and need one to happen before an other to work correctly.


5. Describe what comm_serve does. How are the response and command parameters used? What would happen if the stream pointed to by cxstr were closed?
What comme_server does is it takes in a command and a response, and will print out the previous response that was given by the past command and then take in the new command and create a new response for that new command to then be intepreted. If the cxstr stream were closed, the client connections would be terminated.

6. Describe, in detail, what happens during each iteration of the while loop in the listener function. Be sure to include explanations of all significant function calls.
During each iteration of the while loop, a client socket is made. Then, the listener socket accepts a connection and sets the client sock to that socket with the function call accept. From there we print out that it received a connection if the accepting of the client into the socket was successful. After that, we open the cxstr stream and then close it if it needs to be closed. Then we call the server with the cxstr which is the stream and our database runs and accespts clients.